"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("@layer0/core/constants");
const environment_1 = require("@layer0/core/environment");
const nextPathFormatter_1 = require("./nextPathFormatter");
const fs_1 = require("fs");
const getDistDir_1 = __importDefault(require("../util/getDistDir"));
const nonWebpackRequire_1 = __importDefault(require("@layer0/core/utils/nonWebpackRequire"));
const path_1 = require("path");
const PluginBase_1 = __importDefault(require("@layer0/core/plugins/PluginBase"));
const renderNextPage_1 = __importDefault(require("./renderNextPage"));
const constants_2 = require("./constants");
const watch_1 = __importDefault(require("@layer0/core/utils/watch"));
const slash_1 = __importDefault(require("slash"));
const config_1 = __importDefault(require("@layer0/core/config"));
const getServerBuildAvailability_1 = require("../util/getServerBuildAvailability");
const FAR_FUTURE_CACHE_CONFIG = {
    browser: {
        maxAgeSeconds: constants_2.FAR_FUTURE_TTL,
    },
    edge: {
        maxAgeSeconds: constants_2.FAR_FUTURE_TTL,
    },
};
const PUBLIC_CACHE_CONFIG = {
    edge: {
        maxAgeSeconds: constants_2.FAR_FUTURE_TTL,
    },
};
const TYPE = 'NextRoutes';
// `page` param has no effect when using `server` target.
const renderNextPage = (page, res) => renderNextPage_1.default(page, res, /* istanbul ignore next */ /* istanbul ignore next */ params => params, { rewritePath: false });
class NextRoutes extends PluginBase_1.default {
    /**
     * Provides next registered routes to router
     * @param nextRootDir The root directory for the Next.js app
     */
    constructor(nextRootDir = '.') {
        super();
        this.nextRouteGroupName = 'next_routes_group';
        this.type = TYPE;
        this.nextRootDir = nextRootDir;
        this.pagesDirRelative = 'pages';
        this.pagesDir = path_1.join(process.cwd(), this.nextRootDir, this.pagesDirRelative);
        this.distDir = getDistDir_1.default();
        this.renderMode = 'serverless';
        try {
            const config = nonWebpackRequire_1.default(path_1.join(process.cwd(), 'next.config.js'));
            const { useServerBuild } = getServerBuildAvailability_1.getServerBuildAvailability({ config });
            /* istanbul ignore next */
            this.renderMode = useServerBuild ? 'server' : 'serverless';
        }
        catch {
            // default to 'serverless'
        }
        if (!fs_1.existsSync(this.pagesDir)) {
            this.pagesDirRelative = path_1.join('src', 'pages');
            this.pagesDir = path_1.join(process.cwd(), this.nextRootDir, this.pagesDirRelative);
        }
        if (environment_1.isProductionBuild() || environment_1.isCloud()) {
            this.loadRewrites();
        }
        else {
            this.loadRewritesInDev().then(() => {
                if (this.rewrites || this.redirects) {
                    this.updateRoutes();
                }
            });
        }
    }
    /**
     * Attempt to get rewrites and redirects from routes-manifest.json in production.
     */
    loadRewrites() {
        const manifestPath = process.env.NEXT_ROUTES_MANIFEST_PATH ||
            path_1.join(process.cwd(), this.distDir, 'routes-manifest.json');
        this.routesManifest = nonWebpackRequire_1.default(manifestPath);
        const { rewrites, redirects } = this.routesManifest;
        this.rewrites = rewrites;
        this.redirects = redirects;
    }
    /**
     * Returns the contents of pages-manifest.json
     */
    getPagesManifest() {
        return nonWebpackRequire_1.default(path_1.join(process.cwd(), this.distDir, this.renderMode, 'pages-manifest.json'));
    }
    /**
     * Returns the contents of prerender-manifest.json
     */
    getPrerenderManifest() {
        return nonWebpackRequire_1.default(path_1.join(process.cwd(), this.distDir, 'prerender-manifest.json'));
    }
    /**
     * Attempt to get rewrites and redirects from the next config in development.
     */
    async loadRewritesInDev() {
        // @ts-ignore
        const app = global.LAYER0_NEXT_APP;
        let nextConfig = app.nextConfig;
        if (!nextConfig) {
            nextConfig = await app.loadConfig();
        }
        /* istanbul ignore if */
        if (!nextConfig) {
            return;
        }
        const rewritesFn = nextConfig.rewrites;
        if (rewritesFn) {
            this.rewrites = await rewritesFn();
        }
        const redirectsFn = nextConfig.redirects;
        if (redirectsFn) {
            this.redirects = await redirectsFn();
        }
    }
    /**
     * Called when plugin is registered
     * @param router The router to which the plugin has been added.
     */
    onRegister(router) {
        this.router = router;
        /* create route group and add all next routes into it */
        this.router.group(this.nextRouteGroupName, group => this.addNextRoutesToGroup(group));
        this.router.fallback(res => this._render404(res));
        if (!environment_1.isProductionBuild()) {
            watch_1.default(this.pagesDir).on('all', () => this.updateRoutes());
        }
    }
    /**
     * Update routes
     */
    updateRoutes() {
        var _a, _b, _c;
        /* istanbul ignore next */
        const routeGroup = ((_c = (_b = (_a = this.router) === null || _a === void 0 ? void 0 : _a.routeGroups) === null || _b === void 0 ? void 0 : _b.findByName(this.nextRouteGroupName)) === null || _c === void 0 ? void 0 : _c.clear());
        this.addNextRoutesToGroup(routeGroup);
    }
    /**
     * Adds next routes to route group.
     * @param group The RouteGroup to which Next.js routes should be added.
     */
    addNextRoutesToGroup(group) {
        var _a, _b, _c;
        this.addRedirects(group);
        this.addRewrites((_a = this.rewrites) === null || _a === void 0 ? void 0 : _a.beforeFiles, group);
        this.addAssets(group);
        this.addImageOptimizerRoutes(group);
        this.addRewrites((_b = this.rewrites) === null || _b === void 0 ? void 0 : _b.afterFiles, group);
        if (environment_1.isProductionBuild()) {
            this.addMiddlewareManifest(group);
            this.addPagesInProd(group);
            this.addPrerendering();
        }
        else {
            this.addPagesInDev(group);
        }
        const fallbackRewrites = ((_c = this.rewrites) === null || _c === void 0 ? void 0 : _c.fallback) || this.rewrites;
        if (Array.isArray(fallbackRewrites)) {
            this.addRewrites(fallbackRewrites, group);
        }
    }
    /**
     * Adds the route for server assets such as the middleware manifest
     * @param group
     */
    addMiddlewareManifest(group) {
        group.match('/_next/server/:file*', ({ serveStatic, cache }) => {
            cache({ edge: { maxAgeSeconds: constants_2.FAR_FUTURE_TTL } });
            serveStatic(`${this.distDir}/server/:file*`);
        });
    }
    /**
     * Creates a Layer0 RouteCriteria from path and has attributes found in rewrites in redirects
     * in next.config.js.
     * @param path The path pattern
     * @param has Has elements from next.config.js rewrites and redirects.
     * @returns
     */
    createRouteCriteria(path, has) {
        // Next.js adds /:nextInternalLocale(...) at the start of the source route - if we leave this in
        // the actually requests from the browser will never match.
        let criteria = path.replace(/\/:nextInternalLocale[^/]+/, '');
        if (has) {
            let headers = {};
            let cookies = {};
            let query = {};
            for (let el of has) {
                if (typeof el.value === 'string' && el.value.match(/\(\?<[^>]+>/)) {
                    throw new Error('Layer0 does not yet support capturing named parameters in `has` elements of `rewrites` or `redirects` in next.config.js.');
                }
                if (el.type === 'header') {
                    headers[el.key] = el.value ? new RegExp(el.value) : /.*/;
                }
                else if (el.type === 'host') {
                    headers.host = new RegExp(el.value);
                }
                else if (el.type === 'cookie') {
                    cookies[el.key] = el.value ? new RegExp(el.value) : /.*/;
                }
                else if (el.type === 'query') {
                    query[el.key] = el.value ? new RegExp(el.value) : /.*/;
                }
                else {
                    console.warn(`Warning: has.type ${el.type} is not supported by Layer0`);
                }
            }
            return {
                path: criteria,
                headers: Object.keys(headers).length ? headers : undefined,
                cookies: Object.keys(cookies).length ? cookies : undefined,
                query: Object.keys(query).length ? query : undefined,
            };
        }
        else {
            return criteria;
        }
    }
    /**
     * Find an existing route that would match a request with destination as the path - we will run its handler when
     * the request's path matches the rewrite source.
     * @param group The route group
     * @param source The source URL
     * @param has Any has elements
     * @param destination The destination URL
     */
    addRewrite(group, source, has, destination) {
        // Next.js adds /:nextInternalLocale at the start of the destination route - if we leave this in
        // we'll never find the destination route
        let normalizedDestination = destination.replace(/\/:nextInternalLocale[^/]*/, '');
        if (this.defaultLocale) {
            // Use the defaultLocale in place of the the :locale parameter since we restrict the locale to only the
            // configured locales. If we don't do this, we'll never find the destination route.
            normalizedDestination = normalizedDestination.replace(/:locale/, this.defaultLocale);
        }
        if (environment_1.isProductionBuild()) {
            console.debug(`[rewrite] ${source} => ${normalizedDestination}`);
        }
        if (destination.match(/^https?:\/\//)) {
            const url = new URL(destination);
            const backend = this.backendForDestination(url);
            if (backend) {
                // proxy
                group.match(this.createRouteCriteria(source, has), ({ proxy }) => {
                    proxy(backend, { path: url.pathname });
                });
            }
            else {
                console.warn(`No matching backend was found in layer0.config.js for rewrite to ${url.toString()}. ` +
                    `To fix this problem, add key to the backends config with the following value: { "domainOrIp": "${url.hostname}" }. ` +
                    `See https://docs.layer0.co/guides/layer0_config#section_backends for more information.`);
            }
        }
        else {
            // render
            group.match(this.createRouteCriteria(source, has), res => {
                const destRoute = group.routes.find(route => {
                    return route.match({ path: normalizedDestination });
                });
                if (destRoute) {
                    // need to extract the params again based on the new path
                    res.rewrite(destination, destRoute.criteria.path);
                    destRoute.handler(res);
                }
                else {
                    console.warn(`No matching route found for rewrite ${source} => ${destination}`);
                }
            });
        }
    }
    /**
     * Finds a backend in layer0.config.js that has the same hostname as the specified rewrite destination URL.
     * @param urlStr
     * @returns
     */
    backendForDestination(url) {
        const backends = config_1.default.get('backends', {});
        const entry = Object.entries(backends).find(([_key, value]) => value.domainOrIp === url.hostname);
        if (entry) {
            return entry[0];
        }
    }
    addRewrites(rewrites, group) {
        if (rewrites) {
            for (let { source, destination, has } of rewrites) {
                this.addRewrite(group, source, has, destination);
            }
        }
    }
    /**
     * Adds rewrites and redirects from next.config.js
     * @param group The group to which to add redirect routes
     */
    addRedirects(group) {
        if (this.redirects) {
            for (let { source, has, statusCode, destination } of this.redirects) {
                if (source !== '/:path+/') {
                    // We remove the redirect that next.js automatically adds to remove trailing slashes because we already
                    // do this in our own serveStatic implementation, and this redirect would prevent the fallback from working
                    // because it would match all routes except '/'
                    group.match(this.createRouteCriteria(source, has), ({ redirect }) => {
                        redirect(destination, { statusCode: statusCode || 302 });
                    });
                }
            }
        }
    }
    /**
     * Adds routes for all pages and corresponding data in development
     * @param group The group to which to add page routes
     */
    addPagesInDev(group) {
        const nextHandler = (res) => res.proxy(constants_1.BACKENDS.js);
        // data,
        group.dir(this.pagesDirRelative, {
            ignore: ['_*'],
            paths: (file) => {
                let route = nextPathFormatter_1.toRouteSyntax(file);
                if (route.endsWith('/')) {
                    route += 'index';
                }
                return [`/_next/data/:build${route}.json`];
            },
            handler: () => nextHandler,
        });
        // SSR,
        group.dir(this.pagesDirRelative, {
            ignore: ['_*'],
            paths: (file) => [nextPathFormatter_1.toRouteSyntax(file)],
            handler: () => nextHandler,
        });
    }
    /**
     * Adds routes for react components and API handlers
     * @param group The group to which to add page routes
     */
    addPagesInProd(group) {
        var _a, _b;
        const { routesManifest } = this;
        const pagesManifest = this.getPagesManifest();
        const prerenderManifest = this.getPrerenderManifest();
        const locales = (_a = routesManifest.i18n) === null || _a === void 0 ? void 0 : _a.locales;
        this.defaultLocale = (_b = routesManifest.i18n) === null || _b === void 0 ? void 0 : _b.defaultLocale;
        const pagesWithDataRoutes = new Set(routesManifest.dataRoutes.map((route) => route.page));
        const addRoute = (label, route, handler) => {
            console.debug(`[${label}]`, route);
            group.match(route, handler);
        };
        const startsWithLocale = (path) => locales && new RegExp(`^/(${locales.join('|')})(/|$)`).test(path);
        const localizationEnabled = (locales === null || locales === void 0 ? void 0 : locales.length) > 0;
        console.debug(`Next.js routes (locales: ${(locales === null || locales === void 0 ? void 0 : locales.join(', ')) || 'none'})`);
        console.debug('--------------');
        const pages = sortRoutes(Object.keys(pagesManifest), routesManifest);
        for (let page of pages) {
            const path = nextPathFormatter_1.toRouteSyntax(page);
            const isPrerendered = this.isPrerendered(prerenderManifest, pagesManifest, page);
            if (page.startsWith('/api')) {
                // api routes
                addRoute('api', path, res => renderNextPage(page.slice(1), res));
            }
            else if (startsWithLocale(page) && !page.startsWith(`/${this.defaultLocale}`)) {
                // When the app uses internationalization, we collapse all localized routes into a single
                // route to save router spacer, so for example en-US/sale and fr/sale become /:locale(en-US|fr)?/category/sale
            }
            else if (isPrerendered) {
                // SSG
                const dynamicRouteConfig = prerenderManifest.dynamicRoutes[page];
                const nonLocalizedPath = startsWithLocale(path) ? this.removeLocale(path) : path;
                const nonLocalizedPage = startsWithLocale(page) ? this.removeLocale(page) : page;
                const modifier = dynamicRouteConfig
                    ? ` (Î»${dynamicRouteConfig.fallback ? ' w/fallback' : ''})`
                    : '';
                if (pagesWithDataRoutes.has(page)) {
                    // JSON
                    addRoute(`SSG ${modifier}json`, `/_next/data/:__build__${nextPathFormatter_1.localize(locales, nextPathFormatter_1.toRouteSyntax(nonLocalizedPath, { suffix: 'json' }))}`, this.createSSGHandler(nonLocalizedPage, {
                        dataRoute: true,
                        localize: localizationEnabled,
                        dynamicRouteConfig,
                    }));
                }
                // HTML
                addRoute(`SSG ${modifier}html`, nextPathFormatter_1.localize(locales, nextPathFormatter_1.toRouteSyntax(nonLocalizedPath)), this.createSSGHandler(nonLocalizedPage, {
                    localize: localizationEnabled,
                    dynamicRouteConfig,
                }));
            }
            else {
                // SSR
                if (pagesWithDataRoutes.has(page)) {
                    // will not get here when the page uses getInitialProps
                    addRoute('SSR json', `/_next/data/:__build__${nextPathFormatter_1.localize(locales, nextPathFormatter_1.toRouteSyntax(page, { suffix: 'json' }))}`, this.createSSRHandler(page));
                }
                // SSR: getServerSideProps or getInitialProps
                addRoute('SSR html', nextPathFormatter_1.localize(locales, nextPathFormatter_1.toRouteSyntax(page)), this.createSSRHandler(page));
            }
        }
    }
    /**
     * Returns true if the specified page was statically rendered at build time (no getServerSideProps or getInitialProps)
     * @param prerenderManifest The prerender-manifest.json file
     * @param pagesManifest the pages-manifest.json file
     * @param page The page key
     * @returns
     */
    isPrerendered(prerenderManifest, pagesManifest, page) {
        const file = pagesManifest[page];
        const htmlPath = path_1.join(this.distDir, this.renderMode, 'pages', `${page}.html`);
        const routeKey = (this.defaultLocale ? `/${this.defaultLocale}` : '') + `${page}`.replace(/\/$/, '');
        return (file.endsWith('.html') ||
            prerenderManifest.routes[routeKey] != null ||
            prerenderManifest.dynamicRoutes[page] != null ||
            fs_1.existsSync(htmlPath));
    }
    /**
     * Removes the locale part from the start of path
     * @param path E.g /en-US/p/[id]
     * @returns the path minus the locale, e.g /p/[id]
     */
    removeLocale(path) {
        const [_, _locale, ...rest] = path.split('/');
        return '/' + rest.join('/');
    }
    /**
     * Automatically configure prerendering to pull all SSG pages into the edge cache.
     * This only needs to be done during a production build.
     */
    addPrerendering() {
        const { routes } = this.getPrerenderManifest();
        const requests = [];
        for (let htmlPath in routes) {
            const route = routes[htmlPath];
            requests.push({ path: htmlPath });
            requests.push({ path: route.dataRoute });
        }
        const router = this.router;
        // @ts-ignore - The typings for this methods
        router.prerender(requests);
    }
    /**
     * Production route handler for all dynamic HTML and JSON requests (SSR and SSG).
     * @param page The next.js page to render
     */
    createSSRHandler(page) {
        // Note, we do not need to look up revalidate times from prerender-manifest.json
        // because Next automatically set cache-control: s-maxage=(revalidate), stale-while-revalidate
        return (res) => renderNextPage(page.slice(1), res);
    }
    /**
     * Creates a handler for SSG pages that can be optionally configured with fallback: trlayer0dfdue
     * @param relativeAssetPath The asset path relative to .next/serverless
     * @param options
     */
    createSSGHandler(relativeAssetPath, { dataRoute, localize, dynamicRouteConfig, }) {
        return (res) => {
            const suffix = dataRoute ? 'json' : 'html';
            const assetRoot = `${this.distDir}/${this.renderMode}/pages${localize ? '/:locale' : ''}`;
            const prerenderManifest = this.getPrerenderManifest();
            if (dynamicRouteConfig) {
                // will get here if the page has getStaticProps
                const assetFile = nextPathFormatter_1.toRouteSyntax(relativeAssetPath, { suffix }).replace(/\/\.(json|html)$/, '.$1'); // fix for :locale/index.js
                const assetPath = `${assetRoot}${assetFile}`;
                let { fallback } = dynamicRouteConfig;
                let loadingPage = !dataRoute && fallback ? `${assetRoot}${fallback}` : undefined;
                // Note that the cache TTL is stored as a header on S3 based on the prerender-manifest.json,
                // so we don't need to use res.cache() here.
                res.serveStatic(assetPath, {
                    loadingPage,
                    onNotFound: () => {
                        const isPrerendered = prerenderManifest.routes[res.request.path];
                        // Note that fallback: 'blocking' in getStaticPaths results in fallback: null in prerender-manifest.json
                        if (fallback !== false || isPrerendered || dataRoute) {
                            // Fallback to SSR when fallback: true is set in getStaticPaths or when revalidating a prerendered page or when it's a data path
                            return renderNextPage(relativeAssetPath, res);
                        }
                        else {
                            // Render the custom 404 when a static page is not found.
                            return this._render404(res);
                        }
                    },
                });
            }
            else {
                // well get here if the page does not have getStaticProps
                let assetPath = `${slash_1.default(path_1.join(assetRoot, relativeAssetPath))}`;
                if (assetPath.endsWith('/')) {
                    assetPath += 'index';
                }
                res.serveStatic(`${assetPath}.${suffix}`, {
                    onNotFound: () => renderNextPage(relativeAssetPath, res),
                });
            }
        };
    }
    /**
     * Renders the the 404 page.
     *
     * Example:
     *
     * ```js
     *  import { nextRoutes } from '@layer0/next'
     *  import { Router } from '@layer0/core/router'
     *
     *  export default new Router()
     *    .get('/some/missing/page', (res) => {
     *      nextRoutes.render404(res)
     *    })
     *    .use(nextRoutes)
     * ```
     *
     * @param res The ResponseWriter to use to send the response
     */
    async render404(res) {
        // This method is retired for use with a server build. _render404 kept for internal use and backwards
        // compatibility with older versions using this method.
        /* istanbul ignore if */
        if (this.renderMode === 'server') {
            throw new Error('The use of `NextRoutes.render404` is retired for use with a server target build.\n' +
                'More information: https://docs.layer0.co/guides/next#section_next_js_version_12_and_next_js_middleware__beta_');
        }
        else {
            await this._render404(res);
        }
    }
    async _render404(res) {
        if (environment_1.isCloud()) {
            /* istanbul ignore if */
            if (this.renderMode === 'server') {
                // Delegate to server in server mode
                return renderNextPage('', res);
            }
            else {
                const pagesManifest = this.getPagesManifest();
                const notFoundPage = pagesManifest['/404'] || pagesManifest[`/${this.defaultLocale}/404`];
                const assetRoot = `${this.distDir}/${this.renderMode}/pages${this.defaultLocale ? '/:locale' : ''}`;
                if (notFoundPage && notFoundPage.endsWith('.html')) {
                    // static 404
                    await res.serveStatic(`${assetRoot}/404.html`, {
                        statusCode: 404,
                        statusMessage: 'Not Found',
                    });
                }
                else {
                    // dynamic 404
                    res.response.statusCode = 404;
                    res.response.statusMessage = 'Not Found';
                    await renderNextPage('404', res);
                }
            }
        }
        else {
            return renderNextPage('404', res);
        }
    }
    /**
     * Adds routes for static assets, including /public and /.next/static
     * @param group The RouterGroup to which asset routes should be added
     */
    addAssets(group) {
        // public assets
        group.static(path_1.join(this.nextRootDir, 'public'), {
            handler: (file) => (res) => res.cache(PUBLIC_CACHE_CONFIG),
        });
        // webpack hot loader
        if (!environment_1.isCloud()) {
            group.match('/_next/webpack-hmr', ({ stream }) => stream('__js__'));
        }
        const staticHandler = ({ proxy, serveStatic, cache }) => {
            if (environment_1.isCloud() || environment_1.isProductionBuild()) {
                cache(FAR_FUTURE_CACHE_CONFIG);
                serveStatic(`${this.distDir}/static/:path*`, {
                    permanent: true,
                    exclude: [path_1.join(this.distDir, 'static', 'service-worker.js')],
                });
            }
            else {
                proxy(constants_1.BACKENDS.js);
            }
        };
        // browser js
        // Notes:
        // - Assets with unique hashed filenames like JS, Css, and media are stored
        //   in a persistent bucket to be available across builds
        // - We can't apply that rule to the whole /static folder as it contains
        //   non-unique filenames like 'service-worker.js'. This will
        group.match('/_next/static/:path*', staticHandler);
        group.match('/autostatic/:path*', staticHandler);
    }
    /**
     * Adds routes for image-optimizer
     * @param group The RouterGroup to which image optimizer routes should be added
     */
    addImageOptimizerRoutes(group) {
        group.match('/_next/image', ({ proxy }) => {
            // By default '/_next/image' indicates the image is to be optimized.
            // When we are local, we do not need to modify the path as the
            // local framework will, by default, optimize the image for us.
            // But in the cloud we replace '/_next/image' the '/__layer0_image_optimizer'
            // so Layer0 Buffer Proxy can route to the right lambda.
            const production = environment_1.isProductionBuild();
            const backend = production ? constants_1.BACKENDS.imageOptimizer : constants_1.BACKENDS.js;
            const opts = production ? { path: constants_1.LAYER0_IMAGE_OPTIMIZER_PATH } : undefined;
            proxy(backend, opts);
        });
    }
}
exports.default = NextRoutes;
/**
 * Sort static routes before dynamic routes
 * @param pages Page paths
 * @param routesManifest The routes manifest generated by Next's build
 */
function sortRoutes(pages, routesManifest) {
    const isDynamic = (page) => routesManifest.dynamicRoutes.find((r) => r.page === page);
    const indexFor = (page) => routesManifest.dynamicRoutes.findIndex((r) => r.page === page);
    let staticRoutes = [], dynamicRoutes = [];
    for (let page of pages) {
        if (isDynamic(page)) {
            dynamicRoutes.push(page);
        }
        else {
            staticRoutes.push(page);
        }
    }
    // Dynamic routes are ordered by priority (least dynamic to most dynamic)
    // in the routes-manifest.js file. Follow the same order for layer0 routes.
    dynamicRoutes.sort((pageA, pageB) => {
        return indexFor(pageA) - indexFor(pageB);
    });
    return staticRoutes.concat(dynamicRoutes);
}
exports.sortRoutes = sortRoutes;
