"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("@layer0/core/constants");
const constants_2 = require("../constants");
const log_1 = __importDefault(require("./log"));
const prefetch_1 = require("./prefetch");
const origin = new URL(self.origin);
function isPrefetchRequest(request) {
    return new URL(request.url).searchParams.has(constants_1.DEVTOOLS_PREFETCH_QUERY_PARAM);
}
exports.isPrefetchRequest = isPrefetchRequest;
async function normalizeRequestUrlForCache(request, { cacheHost } = {}) {
    request = request.clone();
    const url = new URL(request.url);
    // When reading/writing cacheHost URLs convert them back to origin
    if (cacheHost && url.hostname == cacheHost.hostname) {
        url.host = origin.host;
        url.protocol = origin.protocol;
    }
    const method = request.method.toLowerCase();
    // For non-GET requests, we need to add the request body to the cache key by appending in to the URL query string
    if (method !== 'get') {
        let body = await request.text();
        const bodyParam = url.searchParams.get(constants_1.POST_BODY_QUERY_PARAM);
        if (!bodyParam && body) {
            url.searchParams.set(constants_1.POST_BODY_QUERY_PARAM, encodeURIComponent(body));
        }
        // add method to the cache key so that we can cache requests to the same path with different methods
        url.searchParams.set(constants_1.METHOD_QUERY_PARAM, request.method.toLowerCase());
    }
    // remove layer0_prefetch and layer0_dt_pf query params so that prefetches and real requests
    // return from the same cache space
    url.searchParams.delete(constants_1.THROTTLED_QUERY_PARAM);
    url.searchParams.delete(constants_1.DEVTOOLS_PREFETCH_QUERY_PARAM);
    // Decode query parameters both when writing to cache and when reading
    // from cache. This ensures the cache is used no matter whether the URL
    // is encoded in either step.
    decodeQueryParams(url);
    return url.toString();
}
exports.normalizeRequestUrlForCache = normalizeRequestUrlForCache;
class PrefetchPlugin {
    constructor({ incrementRead, incrementWrite, cacheHost, prefetchUpstreamRequests, }) {
        this.incrementRead = incrementRead;
        this.incrementWrite = incrementWrite;
        this.cacheHost = cacheHost;
        this.prefetchUpstreamRequests = prefetchUpstreamRequests;
    }
    async requestWillFetch({ request }) {
        // We need to send a clone of the request so that we can read the request body and use
        // it in the cache key in the write phase of the cacheKeyWillBeUsed method.
        return request.clone();
    }
    /**
     * Called when an object is read from or written to the cache.  Here we
     * compute cache stats and ensure that ?layer0_prefetch is removed from the cache key so
     * that future requests for prefetched resources will match.
     */
    async cacheKeyWillBeUsed({ request, mode }) {
        if (!isPrefetchRequest(request)) {
            if (mode === 'read') {
                this.incrementRead();
            }
            else {
                this.incrementWrite();
            }
        }
        return normalizeRequestUrlForCache(request, { cacheHost: this.cacheHost });
    }
    /**
     * Called when a response is about to be written to the cache.
     */
    async cacheWillUpdate({ response, request }) {
        // If prefetchUpstreamRequests is set, we only prefetch the html pages in SPA mode
        // (e.g Angular) to get the upstream requests response header.  We don't actually want
        // to serve the html from the cache, so this returns null:
        if (this.prefetchUpstreamRequests) {
            const backendRequests = response.headers.get(constants_2.BACKEND_REQUESTS_RESPONSE_HEADER_NAME);
            if (backendRequests) {
                const urlsToPrefetch = backendRequests.split(';');
                urlsToPrefetch.forEach(url => {
                    if (url)
                        prefetch_1.prefetch(url);
                });
            }
            return null;
        }
        // Service workers do not handle redirects well. If a redirected response is put in the cache,
        // you'll see this error: "a ServiceWorker passed a redirected Response to FetchEvent.respondWith()
        // while RedirectMode is not â€˜follow"
        // Returning null here prevents the response from being cached
        if (response.redirected) {
            log_1.default(`${response.url} was not added to the cache because it was a redirect.`);
            return null;
        }
        else {
            log_1.default(`${response.url} was added to the cache with key ${request.url}.`);
            return response;
        }
    }
}
exports.default = PrefetchPlugin;
/**
 * Mutates the searchParams object, ensuring that each value is decoded.
 * @param {URL} url The URL whose params should be decoded
 */
function decodeQueryParams(url) {
    const maybeDecode = (val) => {
        try {
            return decodeURIComponent(val);
        }
        catch (e) {
            // it will fail if the string has a % in it that isn't a URL-decoded entity,
            // so that means the string is already decoded so we can just return the value:
            return val;
        }
    };
    url.searchParams.forEach((param, key) => {
        url.searchParams.set(maybeDecode(key), maybeDecode(param));
    });
}
