"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const workbox_routing_1 = require("workbox-routing");
const workbox_strategies_1 = require("workbox-strategies");
const workbox_expiration_1 = require("workbox-expiration");
const workbox_cacheable_response_1 = require("workbox-cacheable-response");
const constants_1 = require("../constants");
const log_1 = __importDefault(require("./log"));
const PrefetchPlugin_1 = __importDefault(require("./PrefetchPlugin"));
const DevtoolsPlugin_1 = __importDefault(require("./DevtoolsPlugin"));
const messageBrowser_1 = __importDefault(require("./messageBrowser"));
const CustomCacheKeyPlugin_1 = __importDefault(require("./CustomCacheKeyPlugin"));
const ChangeMethodPlugin_1 = __importDefault(require("./ChangeMethodPlugin"));
class Stats {
    constructor() {
        this.hits = 0;
        this.misses = 0;
    }
}
exports.Stats = Stats;
const BUFFER_DELAY_MS = 10000;
/**
 * Handles prefetching and caching in the the service worker.  Responses
 * are cached based on the `browser.serviceWorkerSeconds` cache setting in your routes.
 *
 * **Example routes.js**
 *
 * ```js
 *  import { Router } from '@layer0/core/router'
 *
 *  module.exports = new Router()
 *    .match('/some/path', ({ cache }) => {
 *      cache({
 *        edge: {
 *          maxAgeSeconds: 60 * 60 * 24 // one day
 *        },
 *        browser: {
 *          serviceWorkerSeconds: 60 * 60 // one hour
 *        }
 *      })
 *    })
 * ```
 *
 * **Example Service Worker**
 *
 * ```js
 *  import { skipWaiting, clientsClaim } from 'workbox-core'
 *  import { Prefetcher } from '@layer0/prefetch/sw'
 *  import { precacheAndRoute } from 'workbox-precaching'
 *
 *  skipWaiting()
 *  clientsClaim()
 *  precacheAndRoute(self.__WB_MANIFEST || [])
 *
 *  new Prefetcher().route()
 * ```
 */
class Prefetcher {
    constructor(config = { plugins: [] }) {
        // For performance reasons, Devtools plugins are disabled until the first
        // 'layer0-devtools-syn' message is received (ie: a Devtools client is enabled).
        // But once enabled, they will remain active until the Service Worker is reinstalled
        this.devtoolsEnabled = false;
        /**
         * bufferedDevtoolMessages keeps track of the request received in the last BUFFER_DELAY_MS.
         */
        this.bufferedDevtoolMessages = [];
        this.config = config;
        let manifestURL = '__layer0__/cache-manifest.js';
        this.cacheOrigins = [self.origin];
        if (config.cacheHost) {
            this.cacheHost = new URL(`https://${config.cacheHost}`);
            this.cacheOrigins.push(this.cacheHost.origin);
            manifestURL = this.cacheHost.toString() + manifestURL;
        }
        importScripts(manifestURL);
        this.cacheableResponsePlugin = new workbox_cacheable_response_1.CacheableResponsePlugin({
            statuses: [200, 301, 302],
        });
        this.stats = new Stats();
        this.initStats();
        this.initDevtoolsHandshakeListener();
    }
    getRouteConfigsFromManifest() {
        // @ts-ignore
        const manifest = self.__LAYER0_CACHE_MANIFEST__;
        return manifest.map(({ criteriaPath, route, cacheOptions, method, returnsResponse }) => {
            var _a, _b, _c;
            const maxAgeSeconds = (_a = cacheOptions.browser) === null || _a === void 0 ? void 0 : _a.serviceWorkerSeconds;
            const edgeMaxAgeSeconds = (_b = cacheOptions.edge) === null || _b === void 0 ? void 0 : _b.maxAgeSeconds;
            return {
                criteriaPath,
                pattern: route,
                method,
                maxAgeSeconds,
                edgeMaxAgeSeconds,
                returnsResponse,
                isPartialPathRoute: true,
                key: cacheOptions.key,
                convertToGet: (_c = cacheOptions.browser) === null || _c === void 0 ? void 0 : _c.convertToGet,
                prefetchUpstreamRequests: cacheOptions.prefetchUpstreamRequests,
            };
        });
    }
    registerDevtoolsRoutes() {
        for (const routeConfig of this.getRouteConfigsFromManifest()) {
            // Add listener for all routes that are not cached in the browser as those already have a route handler
            if (!routeConfig.maxAgeSeconds && !routeConfig.returnsResponse) {
                this.createDevtoolsRoute(routeConfig);
            }
        }
        // Also add a fallback route in case the cache manifest does not specify any
        this.createDevtoolsRoute();
    }
    /**
     * Adds a fetch event listener that serves content from the browser cache when available.  When
     * a request is not in the cache, it will be fetched from the network and added to the
     * cache if the route has `browser.serviceWorkerSeconds` defined in its `cache` setting.
     */
    route() {
        for (const routeConfig of this.getRouteConfigsFromManifest()) {
            if (
            // Only listen for browser cached routes:
            (routeConfig.maxAgeSeconds && routeConfig.maxAgeSeconds > 0) ||
                // or for routes that return an x-0-upstream-requests header:
                routeConfig.prefetchUpstreamRequests) {
                this.createRoute(routeConfig);
            }
            else if (routeConfig.returnsResponse) {
                // register routes that return responses to force a network call and prevent
                // a later route from matching and caching non-cacheable routes:
                const method = (routeConfig.method || 'get').toUpperCase();
                workbox_routing_1.registerRoute(this.shouldIntercept(new RegExp(routeConfig.pattern, 'i'), routeConfig.isPartialPathRoute), new workbox_strategies_1.NetworkOnly({
                    plugins: [this.createDevtoolsPlugin(routeConfig)],
                }), method);
            }
        }
        return this;
    }
    cache(pattern, maxAgeSeconds = 60 * 60 * 24) {
        this.createRoute({ pattern: pattern.source, maxAgeSeconds, isPartialPathRoute: false });
        return this;
    }
    /**
     * Starts listening for messages from the browser
     */
    initStats() {
        self.addEventListener('message', (e) => {
            if (e.data.action === 'get-stats') {
                messageBrowser_1.default({
                    type: 'stats',
                    stats: this.stats,
                });
            }
        });
    }
    /**
     * Here we implement a handshake protocol between the devtool window client and the service worker:
     * 1. Devtools sends the 'layer0-devtools-syn' event and starts listening for 'layer0-devtools-ack' event
     * 2. Service worker receives the 'layer0-devtools-syn' event and sends the 'layer0-devtools-ack' event
     *    along with the buffered messages that were received over the last BUFFER_DELAY_MS.
     *    This is because the window widget takes time to download, load and to start listening from
     *    Service worker message, while the latter is already receiving http requests.
     * 3. Devtools receives the 'layer0-devtools-ack' event, looks for its current page html request,
     *    which corresponds to that tab very first request, and loads requests past that one.
     * 4. Devtools starts listening for live 'layer0-devtools-request' events
     *
     * Notes:
     * - there is no 1-1 channel between window client and Service Worker, so all opened tab
     *   will see the 'layer0-devtools-ack' event. Only the ones in handshake phase will handle it.
     */
    initDevtoolsHandshakeListener() {
        self.addEventListener('message', async (e) => {
            if (e.data.action === 'layer0-devtools-install') {
                if (!this.devtoolsEnabled) {
                    this.registerDevtoolsRoutes();
                    this.devtoolsEnabled = true;
                    // Devtools plugin just got initialized so we missed
                    // a few queries. We send a message so that the browser
                    // refreshes its page.
                    this.sendToAllClients({
                        type: 'layer0-devtools-ack-installed',
                    });
                }
            }
            if (e.data.action === 'layer0-devtools-syn') {
                if (this.devtoolsEnabled) {
                    const ackMessage = {
                        type: 'layer0-devtools-ack',
                        bufferedDevtoolMessages: this.bufferedDevtoolMessages,
                    };
                    this.sendToAllClients(ackMessage);
                }
            }
            if (e.data.action === 'layer0-devtools-clear-cache') {
                caches.keys().then(cacheNames => cacheNames.forEach(name => caches.delete(name)));
            }
        });
    }
    /**
     * Send a postMessage event to all window client.
     * Notes:
     * - When used in multi-tabs, each Devtools will show data from all tabs.
     *   That's a bit buggy but it's the best we can do as it's very hard to establish 1-1 channels
     *   on ServiceWorker/Client interface, for example the message event from the window does not
     *   contain the clientId
     */
    async sendToAllClients(data) {
        messageBrowser_1.default(data, { broadcast: true });
    }
    /**
     * Adds a message to this.bufferedDevtoolMessages and manages the buffer so that
     * we don't keep messages more than BUFFER_DELAY_MS.
     *
     * In case of inactivity we clear the whole buffer after BUFFER_DELAY_MS, so technically
     * a message can stay up to 2 x BUFFER_DELAY_MS in the buffer (a bit less than BUFFER_DELAY_MS old
     * when the latest message arrives and cleared BUFFER_DELAY_MS later)
     * @param message
     */
    addDevtoolsRequestMessageToBuffer(message) {
        this.bufferedDevtoolMessages.push(message);
        this.trimDevtoolsRequestMessageBuffer();
        if (this.clearDevtoolsRequestMessageTimeout) {
            clearTimeout(this.clearDevtoolsRequestMessageTimeout);
        }
        // If no additional request for BUFFER_DELAY_MS, we clear the buffer after that
        this.clearDevtoolsRequestMessageTimeout = setTimeout(() => {
            this.bufferedDevtoolMessages = [];
        }, BUFFER_DELAY_MS);
    }
    /**
     * Remove message that are too old to stay in devtools message buffer
     */
    trimDevtoolsRequestMessageBuffer() {
        let sliceIndex = 0;
        const sliceMinimumTimestamp = Date.now() - BUFFER_DELAY_MS;
        while (this.bufferedDevtoolMessages[sliceIndex] &&
            this.bufferedDevtoolMessages[sliceIndex].timestamp < sliceMinimumTimestamp) {
            sliceIndex++;
        }
        this.bufferedDevtoolMessages = this.bufferedDevtoolMessages.slice(sliceIndex);
    }
    /**
     * If there's a cacheHost configured check whether the pattern to test
     * against is a partial pathname pattern. If so, check that the origin is
     * also correct: service worker's own origin or cacheHost origin
     * @param pattern A route pattern
     * @param isPartialPathRoute Set to true if the supplied pattern only matches the path, false if it matches the whole URL.
     * @param options.skipAssets Set to true to ignore request that are not 'document' or 'empty' (ie: audio, font, image, ...)
     * @return true if the request should be handled by the service worker.
     */
    shouldIntercept(pattern, isPartialPathRoute, { skipAssets = false } = {}) {
        return ({ url, request }) => {
            if (skipAssets &&
                request.destination &&
                !['document', 'empty'].includes(request.destination)) {
                return false;
            }
            if (isPartialPathRoute) {
                return this.cacheOrigins.includes(url.origin) && pattern.test(url.pathname);
            }
            else {
                return pattern.test(url.toString());
            }
        };
    }
    /**
     * Creates a DevtoolsPlugin object to be added to a caching strategy instance
     * @param routeConfig The route config for the given route
     * @private
     */
    createDevtoolsPlugin(routeConfig) {
        return new DevtoolsPlugin_1.default({
            onResponse: this.onResponse.bind(this),
            isEnabledFn: () => this.devtoolsEnabled,
            routeConfig,
        });
    }
    /**
     * Creates a Workbox route which only purpose is to forward requests/response
     * data to the Devtools
     * @param routeConfig The route pattern and caching options specified within the route definition
     *                    If undefined, it catches all GET queries except static assets
     */
    createDevtoolsRoute(routeConfig) {
        let method, routeMatcher;
        if (routeConfig) {
            const { pattern, isPartialPathRoute } = routeConfig;
            const patternRegexp = new RegExp(pattern, 'i');
            routeMatcher = this.shouldIntercept(patternRegexp, isPartialPathRoute, { skipAssets: true });
            method = (routeConfig.method || 'get').toUpperCase();
        }
        else {
            routeMatcher = this.shouldIntercept(/^.*$/, true, { skipAssets: true });
            method = 'GET';
        }
        workbox_routing_1.registerRoute(routeMatcher, new workbox_strategies_1.NetworkOnly({
            plugins: [this.createDevtoolsPlugin(routeConfig)],
        }), 
        // @ts-ignore
        method);
    }
    /**
     * Creates a workbox route.
     * @param routeConfig The route pattern and caching options specified within the route definition
     */
    createRoute(routeConfig) {
        const { pattern, method: optMethod, maxAgeSeconds, isPartialPathRoute, key, convertToGet, } = routeConfig;
        const method = (optMethod || 'get').toLowerCase();
        log_1.default(`[route] ${method} ${pattern}, maxAgeSeconds: ${maxAgeSeconds}`);
        const patternRegexp = new RegExp(pattern, 'i');
        // all routes must have a GET route registered, so Workbox can properly look
        // it up when running workbox-routing/Router#findMatchingRoute:
        if (method !== 'get') {
            this.createRoute({ ...routeConfig, method: 'get' });
        }
        const prefetchPlugin = new PrefetchPlugin_1.default({
            incrementRead: this.incrementRead.bind(this),
            incrementWrite: this.incrementWrite.bind(this),
            cacheHost: this.cacheHost,
            prefetchUpstreamRequests: routeConfig.prefetchUpstreamRequests,
        });
        const plugins = [
            this.cacheableResponsePlugin,
            new workbox_expiration_1.ExpirationPlugin({
                maxAgeSeconds,
            }),
            // DevtoolPlugin needs to be injected before PrefetchPlugin as this later
            // changes request url to normalise the cache key
            this.createDevtoolsPlugin(routeConfig),
            prefetchPlugin,
            ...(this.config.plugins || []),
        ];
        if (key) {
            plugins.push(new CustomCacheKeyPlugin_1.default(patternRegexp, key));
        }
        if (convertToGet) {
            // ChangeMethodPlugin must come before PrefetchPlugin so body is retained:
            plugins.splice(plugins.indexOf(prefetchPlugin), 0, new ChangeMethodPlugin_1.default([patternRegexp]));
        }
        workbox_routing_1.registerRoute(this.shouldIntercept(patternRegexp, isPartialPathRoute), new workbox_strategies_1.CacheFirst({
            cacheName: constants_1.CACHE_NAME,
            matchOptions: {
                ignoreVary: true,
            },
            plugins,
        }), 
        // @ts-ignore
        method.toUpperCase() // HTTPMethods map directly from @layer0/core lowercase => @workbox uppercase
        );
    }
    /**
     * A Read is considered a Hit until a Write happens meaning it was a miss
     * This is based on the fragile assumption that a cache read *always* triggers a write
     * in case of cache miss, which is not true if the backend does not respond for example.
     *
     * This could be fixed by checking the presence of `response` in `cachedResponseWillBeUsed``
     * but that leads to other issues as we cannot discard Prefetch requests at that
     * stage.
     * We could implement the same Hack-ish solution as in DevtoolsPlugin to work around that,
     * but those simple stats are probably going away anyway.
     */
    incrementRead() {
        this.stats.hits++;
    }
    incrementWrite() {
        this.stats.misses++;
        this.stats.hits--;
    }
    async onResponse({ request, response, ttfb, prefetch, browserCache, routeConfig, }) {
        const headers = {};
        response.headers.forEach((value, key) => {
            headers[key] = value;
        });
        const devToolMessage = {
            type: 'layer0-devtools-request',
            timestamp: Date.now(),
            request: {
                method: request.method,
                url: request.url,
                prefetch,
            },
            response: {
                ttfb,
                status: response.status,
                headers,
            },
            browserCache,
            routeConfig,
        };
        this.sendToAllClients(devToolMessage);
        this.addDevtoolsRequestMessageToBuffer(devToolMessage);
    }
}
exports.default = Prefetcher;
