"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const waitForServiceWorker_1 = __importDefault(require("./waitForServiceWorker"));
const constants_1 = require("@layer0/core/constants");
const getHostName_1 = __importDefault(require("./getHostName"));
// According to Fastly, 2^13 (8192) is the max number of bytes allowed for a URL:
const MAX_URL_BYTES = 2 ** 13;
const prefetched = new Set();
const defaults = {
    includeCacheMisses: false,
    cacheHost: undefined,
    spaRoutes: [],
    forcePrefetchRatio: 0,
};
let options = defaults;
/**
 * Configures prefetching options
 * @param opts
 */
function configure(opts) {
    options = { ...defaults, ...opts };
}
exports.configure = configure;
/**
 * Prefetches and caches the specified URL.
 *
 * **Example**
 *
 * ```js
 * import { prefetch } from '@layer0/prefetch/window
 *
 * prefetch('/some/url')
 * ```
 * @param {String} url The URL to prefetch
 * @param {String} as Value to use for the "as" attribute of the <link> tag
 * @param {PrefetchConfiguration} config Options to use for the prefetch
 */
async function prefetch(url, as = 'fetch', config = { cors: 'anonymous' }) {
    if (typeof url === 'undefined') {
        console.error(`prefetch() called with an undefined url`);
        return;
    }
    if (typeof config.cors === 'undefined') {
        config.cors = 'anonymous';
    }
    const cacheUrl = modifyUrl(url, config);
    if (typeof TextEncoder !== 'undefined' &&
        new TextEncoder().encode(cacheUrl).length > MAX_URL_BYTES) {
        console.warn(`URL is too many characters to prefetch and cache: ${cacheUrl}`);
        return;
    }
    if (prefetched.has(cacheUrl)) {
        return;
    }
    prefetched.add(cacheUrl);
    await waitForServiceWorker_1.default();
    const link = document.createElement('link');
    const { relList } = link;
    link.setAttribute('href', cacheUrl);
    if (config.cors) {
        link.setAttribute('crossorigin', config.cors);
    }
    link.setAttribute('rel', relList.supports('preload') && /* istanbul ignore next */ !relList.supports('prefetch')
        ? /* istanbul ignore next */ 'preload'
        : 'prefetch' // Safari does not support prefetch so we use preload instead
    );
    link.setAttribute('as', as);
    document.head.append(link);
}
exports.prefetch = prefetch;
function modifyUrl(url, config) {
    const { body, method } = config;
    const parsed = new URL(url, window.origin);
    maybeAddHeadParam(parsed);
    if (parsed.hostname === getHostName_1.default()) {
        // If we are prefetching from Layer0 sidecar, rewrite the URL to use the sidecar's domain name
        if (options.cacheHost) {
            const cacheHostUrl = new URL(`https://${options.cacheHost}`);
            parsed.hostname = cacheHostUrl.hostname;
            parsed.protocol = cacheHostUrl.protocol;
            parsed.port = cacheHostUrl.port;
        }
        appendSearchParam(parsed, constants_1.DEVTOOLS_PREFETCH_QUERY_PARAM, '1');
        maybeAddThrottleParam(parsed);
    }
    if (body) {
        appendSearchParam(parsed, constants_1.POST_BODY_QUERY_PARAM, body);
    }
    if (method) {
        appendSearchParam(parsed, constants_1.METHOD_QUERY_PARAM, method);
    }
    return parsed.toString();
}
function appendSearchParam(url, name, value) {
    const separator = url.search.length ? '&' : '?';
    url.search += `${separator}${encodeURIComponent(name)}=${encodeURIComponent(value)}`;
}
/**
 * Adds the query param that indicates to the service worker that a request may be throttled
 * @param url
 */
function maybeAddThrottleParam(url) {
    if (!options.includeCacheMisses && shouldAcceptThrottling()) {
        appendSearchParam(url, constants_1.THROTTLED_QUERY_PARAM, '1');
    }
}
/**
 * Returns true if the next prefetch request should only be served from the edge cache.
 * This is done by comparing a random number between 0 and 1 to options.forcePrefetchRatio
 */
function shouldAcceptThrottling() {
    return !options.forcePrefetchRatio || Math.random() > options.forcePrefetchRatio;
}
function maybeAddHeadParam(url) {
    options.spaRoutes.some(routePattern => {
        if (routePattern.test(url.pathname)) {
            appendSearchParam(url, constants_1.HEAD_QUERY_PARAM, '1');
            return true;
        }
    });
}
