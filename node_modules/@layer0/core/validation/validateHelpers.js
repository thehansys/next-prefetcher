"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../types");
/**
 * List of header regexes that will be matched against user provided header name.
 * The following headers are not allowed for user to modify in any way.
 *
 * * `x-0-platform` headers are generated and maintained by Layer0 platform to store intermediate state during request processing
 * * `x-0-version` header should only be manipulated by Layer0 platform
 * * `x-0-t` header should only be manipulated by Layer0 platform
 * * `x-0-components` header should only be manipulated by Layer0 platform
 * * `x-0-status` header should only be manipulated by Layer0 platform
 * * `x-0-lambda-name`  header should only be manipulated by Layer0 platform as otherwise it messes with reverse proxying. Removed by XBP
 * * `x-0-lambda-schedwule-timeout` header should only be manipulated by Layer0 platform as otherwise it messes with reverse proxying. Removed by XBP
 * * `x-0-received-at` header should only be manipulated by Layer0 platform as otherwise it messes with reverse proxying.
 * * `host` header should only be manipulated by Layer0 platform as otherwise it messes with reverse proxying
 * * `x-request-id` header is generated by Layer0 platform and used as unique identifier of requests
 * * `content-length` header cannot be manipulated apart from manipulating the body and we don't support that in the edge
 * * `via` header is used to prevent request loops in the platform
 */
const LAYER0_PROHIBITED_HEADER_NAMES = [
    // Only allowed for platform to manipulate
    /^x-0-platform/i,
    // Blacklist for x-0-* headers
    /^x-0-version$/i,
    /^x-0-t$/i,
    /^x-0-components$/i,
    /^x-0-status$/i,
    /^x-0-lambda-name$/i,
    /^x-0-lambda-schedule-timeout$/i,
    /^x-0-received-at$/i,
    // Blacklist for non x-0-* headers
    /^host$/i,
    /^x-request-id$/i,
    /^content-length$/i,
    /^via$/i,
];
/**
 * List of cookie regexes that will be matched against user provided cookie name.
 * The following cookies are not allowed for user to modify in any way.
 *
 * * `layer0_*` cookies are created and maintained by Layer0 platform (e.g. `layer0_buckets` and `layer0_destination`)
 * * `layer0_devtools_*` cookies allow enabling/disabling the devtools on a per-user or per-environment basisc
 *    (cf. packages/devtools/src/addBuiltInRoutes.js)
 */
const LAYER0_PROHIBITED_COOKIE_NAMES = [/^layer0_/i];
const LAYER0_WHITELISTED_COOKIE_NAMES = [/^layer0_devtools/i];
/**
 * List of all enumeration values for JwtAlgo type
 * we need this to check at runtime whether user passed only
 * allowed values
 */
exports.JWT_ALGO_NAMES = Object.keys(types_1.JwtAlgo).map(name => {
    return {
        name,
        value: types_1.JwtAlgo[name],
    };
});
/**
 * Checks whether the given string is one of the possible
 * values defined by JwtAlgo enum type
 * @param value value to check
 * @returns true if value is one of the JwtAlgo, otherwise false
 */
exports.isJwtAlgo = (value) => {
    return exports.JWT_ALGO_NAMES.find(p => p.value === value) !== undefined;
};
/**
 * Validate that given value is not one of the prohibited header names
 * @param name
 */
exports.isProhibitedHeaderName = (name) => {
    return (LAYER0_PROHIBITED_HEADER_NAMES.find(prohibitedRegex => name.match(prohibitedRegex)) !==
        undefined);
};
/**
 * Validate that prohibited cookie names are not overrideable by the user
 * @param name
 */
exports.isProhibitedCookieName = (name) => {
    return (LAYER0_PROHIBITED_COOKIE_NAMES.find(prohibitedRegex => name.match(prohibitedRegex)) !==
        undefined &&
        LAYER0_WHITELISTED_COOKIE_NAMES.find(whitelistRegexp => name.match(whitelistRegexp)) ===
            undefined);
};
/**
 * @param name header name in format of RFC 7230 specification
 * @returns true if given name is valid header name, otherwise false
 */
exports.isValidHeaderName = (name) => {
    // some sources (CloudFlare) are allowing only these characthers:
    // const pattern = /^[a-zA-Z1-9_-]*$/;
    // but according to specification all printable ASCII characthers are allowed
    // so thus we are leaving less restrictive pattern
    return exports.isValidHeaderValue(name);
};
/**
 * @param value header value in format of RFC 7230 specification
 * @returns true if given value is valid header value, otherwise false
 */
exports.isValidHeaderValue = (value) => {
    // the following link describes allowed characthers:
    // https://www.rfc-editor.org/rfc/rfc7230#:~:text=.%20%20Field%20Value-,Components,-Most%20HTTP%20header
    // basically only printable ASCII characthers are allowed
    const pattern = /^[\x20-\x7E]*$/;
    return pattern.test(value);
};
